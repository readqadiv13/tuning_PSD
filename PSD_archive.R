    ##  (ÅL-`) .°oO (Distribution inference in the special case when you know x & y position in the PDF coordinate system, 2019-01-29)
    ## https://en.wikipedia.org/wiki/List_of_probability_distributions
    ## https://www.vosesoftware.com/riskwiki/Distributionsbycategory.php
    ## https://www.trifields.jp/r-cran-task-view-probability-distributions-693
    ## https://github.com/cran/propagate/blob/master/R/distr-densities.R
    ## https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf

    skipMess. (library ('minpack.lm'))
    formals (nlsLM) $ 'control'  <-  nls.lm.control (maxiter = 1024, nprint = 0)    #  nprint = 1 denotes to show results

    ##  Distribution names in the archive  == (2019-02-16) ========================    #  'Frechet'  'Levy'  bring error when encoding.
    distN.  <-  paste (c ('Amoroso', 'Benini', 'Beta', 'Beta Prime', 'BHP', 'Burr VIII', 'Burr XII', 'Cauchy', 'Chi', 'Dagum', 'Dagum2','Exponentially Beta',
                    'Exponentially Gamma', 'Exponentially Generalized Beta', 'Exponentially modified Gaussian (type 1)', 'Exponentially modified Gaussian (type 2)',
                    'Exponentially Power', 'Fatigue Life', 'Four-parameter Beta', 'Four-parameter Kumaraswamy', 'Frechet', 'Gamma', 'Generalized Beta Prime',
                    'Generalized Beta of the second kind', 'Generalized Fisher-Tippett', 'Generalized Gamma', 'Generalized Gumbel', 'Generalized Inverse Gaussian',
                    'Generalized Normal ver.1', 'Generalized Normal ver.2', 'Generalized Pearson VII', 'Gumbel', 'Inverse Chi', 'Inverse Gamma', 'Inverse Gaussian',
                    'Inverse Rayleigh', 'Johnson\'s SB', 'Johnson\'s SU', 'Levy', 'Logistic', 'Log-Gamma', 'Log-Logistic', 'Log-Normal', 'Nakagami', 'Normal',
                    'Nukiyama-Tanasawa', 'Pearson III', 'Pearson V', 'Pearson VI', 'Pearson VII', 'PERT', 'PERT2', 'Prentice', 'Rayleigh', 'RBW', 'Rice', 'Shifted Gompertz',
                    'Singh-Maddala', 'Skew Normal', 'Skew Log-Normal', 'Student\'s T', 'Three-parameter Lifetime', 'Three-parameter Log-Hyperbolic',
                    'Three-parameter Student', 'Three-parameter Weibull', 'Weibull'), 'distribution')
    distN2.  <-  c ('Dagum2', 'exGauss4', 'GBP', 'GB2', 'SM', 'JSU', 'Log-Logistic')    #  'Log-Normal', 'Nukiyama-Tanasawa', 'LH3', 'Weibull',

    ##  Distribution model archive  ========================
    arXiv.  <- function (df, ... ) {
            def. (c ('x', 'y'), list (xy.coords (df) $ 'x', xy.coords (df) $ 'y'))
            mdlL  <-  list (amoF. (x,y), beniniF. (x,y), betaF. (x,y), betaPrimeF. (x,y), bhpF. (x,y), burr8F. (x,y), burr12F. (x,y), cauchyF. (x,y), chiF. (x,y), dagumF. (x,y),
                          dagum2F. (x,y), exBetaF. (x,y), exGammaF. (x,y), exGenBetaF. (x,y), exGauss3F. (x,y), exGauss4F. (x,y), exPowerF. (x,y), fatigueF. (x,y), beta4F. (x,y),
                          kuma4F. (x,y), frechetF. (x, y), gammaF. (x,y), gbpF. (x,y), gb2F. (x,y), gftF. (x,y), gGammaF. (x,y), gGumbelF. (x,y), gigF. (x,y), gn1F. (x,y), gn2F. (x,y),
                          gPearson7F. (x,y), gumbelF. (x,y), invChiF. (x,y), invGammaF. (x,y), invGaussF. (x,y), invRayleighF. (x,y), jsbF. (x,y), jsuF. (x,y), levyF. (x,y), logisF. (x,y),
                          logGamF. (x,y), logLogF. (x, y), logNormF. (x,y), nakagamiF. (x, y), normF. (x,y), nukiF. (x,y), pearson3F. (x,y), pearson5F. (x,y), pearson6F. (x,y),
                          pearson7F. (x,y), pertF. (x,y), pert2F. (x,y), prenticeF. (x,y), rayleighF. (x,y), rbwF. (x,y), riceF. (x,y), shGompF. (x,y), sinMadF. (x,y), skewNF. (x,y),
                          skewLogNF. (x,y), studentsTF. (x,y), life3F. (x,y), logHype3F. (x,y), student3F. (x,y), weibull3F. (x,y), weibullF. (x,y) )  %>%  setNames (distN.)
            return (mdlL)
    }
    miniXiv.  <- function (df, ... ) {
            def. (c ('x', 'y'), list (xy.coords (df) $ 'x', xy.coords (df) $ 'y'))
            mdlL  <-  list (#  logNormF. (x,y), nukiF. (x,y), logHype3F. (x,y), weibullF. (x,y),
                                dagum2F. (x,y), exGauss4F. (x,y), gbpF. (x,y), gb2F. (x,y), sinMadF. (x,y), jsuF. (x,y), logLogF. (x, y) )  %>%  setNames (distN2.)
            return (mdlL)
    }

    ##  Quasi-y vector generated by a model ========================
    arYiv.  <- function (df, x, ... ) {    #  mdl is got by arXiv. (), and bingo is got by which.min (getAIC. ()).  x is a vector in the target range.
            mdlL  <-  arXiv. (df)
            bingo  <-  getRMSE2. (mdlL)  %>%  which.min (.)    #  bingo also has the distribution name. try 'bingo'.
            mdl  <-  mdlL [[bingo]]
            yout  <-  function (bingo)  list (amoY., beniniY., betaY., betaPrimeY., bhpY., burr8Y., burr12Y., cauchyY., chiY., dagumY., dagum2Y., exBetaY., exGammaY.,
exGenBetaY., exGauss3Y., exGauss4Y., exPowerY., fatigueY., beta4Y., kuma4Y., frechetY., gammaY., gbpY., gb2Y., gftY.,
                                                         gGammaY., gGumbelY., gigY., gn1Y., gn2Y., gPearson7Y., gumbelY., invChiY., invGammaY., invGaussY., invRayleighY.,
                                                         jsbY., jsuY., levyY., logisY., logGamY., logLogY., logNormY., nakagamiY., normY., nukiY., pearson3Y., pearson5Y.,
pearson6Y., pearson7Y., pertY., pert2Y., prenticeY., rayleighY., rbwY., riceY., shGompY., sinMadY., skewNY.,
skewLogNY., studentsTY., life3Y., logHype3Y., student3Y., weibull3Y., weibullY. ) [[bingo]]
            qY  <-  yout (bingo) (mdl, x)
            return (qY)
    }
    arYivAll.  <- function (df, x, ... ) {    #  mdl is got by arXiv. (), and bingo is got by which.min (getAIC. ()).  x is a vector in the target range.
            mdlL  <-  arXiv. (df)
            yout  <-  function (bingo)  list (amoY., beniniY., betaY., betaPrimeY., bhpY., burr8Y., burr12Y., cauchyY., chiY., dagumY., dagum2Y., exBetaY., exGammaY.,
exGenBetaY., exGauss3Y., exGauss4Y., exPowerY., fatigueY., beta4Y., kuma4Y., frechetY., gammaY., gbpY., gb2Y., gftY.,
                                                         gGammaY., gGumbelY., gigY., gn1Y., gn2Y., gPearson7Y., gumbelY., invChiY., invGammaY., invGaussY., invRayleighY.,
                                                         jsbY., jsuY., levyY., logisY., logGamY., logLogY., logNormY., nakagamiY., normY., nukiY., pearson3Y., pearson5Y.,
pearson6Y., pearson7Y., pertY., pert2Y., prenticeY., rayleighY., rbwY., riceY., shGompY., sinMadY., skewNY.,
skewLogNY., studentsTY., life3Y., logHype3Y., student3Y., weibull3Y., weibullY. ) [[bingo]]
            yL  <-  list ()
            for (i in seq (66))  yL [[i]]  <-  yout (i) (mdlL [[i]], x)
            return (yL)
    }
    miniYiv.  <- function (df, x, ... ) {
            if (all (is.na (df)))  return (NA)
            mdlL  <-  miniXiv. (df)
            bingo  <-  getRMSE2. (mdlL)  %>%  which.min (.)    #  getAIC2. (mdlL)
            mdl  <-  mdlL [[bingo]]
            yout  <-  function (bingo)  list (dagum2Y., exGauss4Y., gbpY., gb2Y., sinMadY., jsuY., logLogY. ) [[bingo]]
            qY  <-  yout (bingo) (mdl, x)
            return (qY)
    }    #  ex)  yBase  <-  miniYiv. (dfBase, cx = dfRef [, 1])
    miniXYiv.  <- function (df, ... ) {
            if (is.na (df) %>% all (.))  return (NA)
            mdlL  <-  miniXiv. (df)
            bingo  <-  getRMSE2. (mdlL)  %>%  which.min (.)    #  return the best numer with its name
            mdl  <-  mdlL [[bingo]]
            data.frame (x = df [, 1], y = fitted (mdl))  %>% return (.)
    }

    ##  AIC evaluation by calling distribution archive (NOTE: mdlL is got by arXiv. (df) )  == (2019-11-05) ========================
    getAIC.  <-  function (mdlL, ... )  map. (mdlL, aic.) %>%  t (.)  %>%  as_tibble (., .name_repair = NULL)  %>% setNames (distN.)  %>%  return (.)
    getAIC2.  <-  function (mdlL, ... )  map. (mdlL, aic.) %>%  t (.)  %>%  as_tibble (., .name_repair = NULL)  %>% setNames (distN2.)  %>%  return (.)
    getRMSE.  <-  function (mdlL, ... )  map. (mdlL, rmse.) %>%  t (.)  %>%  as_tibble (., .name_repair = NULL)  %>% setNames (distN.)  %>%  return (.)
    getRMSE2.  <-  function (mdlL, ... )  map. (mdlL, rmse.) %>%  t (.)  %>%  as_tibble (., .name_repair = NULL)  %>% setNames (distN2.)  %>%  return (.)

    ##  Residual Sum of Square  == (2019-05-23) ========================
    rssFit.  <-  function (yRef, yBase1, yBase2, ... ) {
            rss  <-  rep (NA, 1e4 +1)
            ratios  <-  seq (0, 1, by = 1e-4)
            for (i in seq_along (ratios))  rss [i]  <-  {yRef - (ratios [i] *yBase1 +(1 -ratios [i]) *yBase2)}  %>%  {sum (. ^2)}
            finalAns  <-  which.min (rss)  %>%  ratios [.]
        #  quickPlot. (list (data.frame (ratios, rss)), Xlims = c (0, 1), Xlab = 'Mixing Ratio of Base', Ylab = 'Residual Sum of Square'); points (finalAns, min (rss), pch = 19)
            return (finalAns)
    }

    ##  Residual Sum of Square ver.2  == (2019-11-14) ========================
    rssFit2.  <-  function (yRef, yBase1, yBase2, yBase3, refx, cx, ... ) {    #  cx means composite x1 +x2 for y1 & y2.
            LRX  <-  function (Lper, Rper, ... ) {
                    cumsum (0.5 *diff (refx) * (yRef [-1] +yRef [-length (yRef)]))  %>%    #  plot (.)    #  This becomes a sigmoid curve
                    {c (whichNear. (vec = ., ref = Lper), whichNear. (vec = ., ref = Rper)) +1}  %>%  refx [.]  %>% return (.)
            }
            leftX  <-  refx [which.max (yRef)]    #    LRX (0.50, 0.95) [1]
            rightX  <-  LRX (0.50, 0.95) [2]    #  abline (v = LRX (0.50, 095))
            D100  <-  LRX (0.00, 1.00) [2]
            refPartX  <-  refx [whichNear. (vec = refx, ref = leftX) : whichNear. (vec = refx, ref = rightX)]
            refPartY  <-  yRef [whichNear. (vec = refx, ref = leftX) : whichNear. (vec = refx, ref = rightX)]
            comPartX  <-  cx [whichNear. (vec = cx, ref = leftX) : whichNear. (vec = cx, ref = rightX)]

            area  <-  function (x, y, ... )  sum (0.5 *diff (x) * (y [-1] +y [-length (y)]))  %>%  return (.)
            recX  <-  recY  <-  vector ()
            for (stepW in c (0.1, 0.01, 1e-04, 1e-05)) {
                    if (stepW == 0.1)  tenta  <-  c (0, 1) #  Starters for mixing ratio in the loop range
                    Ratio  <-  tenta  %>%  {seq (. [1], . [2], by = stepW)}    #  Make the range narrow gradually
                    Rss  <-  rep (NA, length (Ratio))
                    for (i in seq_along (Ratio)) {    #  Compare not y but area due to different number of points between ref & composit
                            comPartY  <-  {Ratio [i] *yBase1 +(1 -Ratio [i]) *yBase2}  %>%  {. [whichNear. (vec = cx, ref = leftX) : whichNear. (vec = cx, ref = rightX)]}
                            Rss [i]  <-  {area (refPartX, refPartY) -area (comPartX, comPartY)}  %>%  {sum (. ^2)}
                    }
                    recX  <-  c (recX, Ratio)
                    recY  <-  c (recY, Rss)
                    tenta  <-  interval2. (Rss, valley = T) %>%  Ratio [.]
                    if (length (tenta) == 1)  break
            }
            finalAns  <-  mean (tenta)  %>%  {c (., 1 -., 0)}
            ##  Matching ratio of the right tail (curve from D50 to D95) of dfRef
            comPartX2  <-  cx [whichNear. (vec = cx, ref = leftX) : whichNear. (vec = cx, ref = D100)]
            comPartY2  <-  {finalAns [1] *yBase1 +finalAns [2] *yBase2}  %>%  {. [whichNear. (vec = cx, ref = leftX) : whichNear. (vec = cx, ref = D100)]}
            matchRatio_tail  <-  area (comPartX2, comPartY2) /area (refPartX, refPartY) -1
            matchRatio_D50  <-  {finalAns [1] *yBase1 +finalAns [2] *yBase2}  %>%  which.max (.)  %>%  cx [.]  %>%  {. /leftX -1}
            return (list (Ans = finalAns, Tail_match = matchRatio_tail, D50_match = matchRatio_D50) )

            memo  <-  function (...) {
                    ratios  <-  seq (0, 1, by = 1e-5)
                    rss  <-  rep (NA, length (ratios))
                    for (i in seq_along (ratios)) {    #  Compare not y but area due to different number of points between ref & composit
                            comPartY  <-  {ratios [i] *yBase1 +(1 -ratios [i]) *yBase2}  %>%  {. [whichNear. (vec = cx, ref = leftX) : whichNear. (vec = cx, ref = rightX)]}
                            rss [i]  <-  {area (refPartX, refPartY) -area (comPartX, comPartY)}  %>%  {sum (. ^2)}
                    }
                    finalAns  <-  which.min (rss)  %>% ratios [.]
                    plot (ratios, rss, type = 'l', xlim = c (0, 1), ylim = pr. (range (rss), c (-1, 1), 0.08), cex.axis = 0.95) #  Too long to calculate
                    plot (data.frame (x = recX, y = recY) %>% arrange (x), type = 'o', xlim = c (0, 1), ylim = pr. (range (rss), c (-1, 1), 0.08), cex.axis = 0.95)
                    points (finalAns, min (rss), pch = 19, col = 'coral2')
                    mtext ('Mixing Ratio of Base1', side = 1, las = 1, line = par ('mar') [1] -1.01, cex = 0.95)
                    mtext ('Residual Sum of Square', side = 2, las = 3, line = par ('mar') [2] -0.95, cex = 0.95)
            }
    }

    ##  Transforming rate of Frequency into Probability ========================
    freq2dens.  <-  function (df, ... ) {
            def. (c ('x', 'y'), list (df [, 1], df [, 2]))
            areaRate  <-  1 /sum (0.5 *diff (x) * (y [-1] +y [-length (y)]))
            return (data.frame (x = x, y = y *areaRate))
    }

    ##  xy-coordinate of PSD curve from Microtrac data  == (2019-07-19) ========================
    getXYlines.  <-  function (dt, cook = T, ... ) {
            ##  x channel and y frequency of PSD data
            Xch  <-  str_which (names (dt), pattern = 'class') %>%  names (dt) [.]  %>%  parse_number (.)
            Ypsd  <-  select (dt, starts_with ('class'))

            ##  slice y data at every row and transform PSD with interpolation
            pullRealValues  <-  function (rowVec, ... ) {
                    if (is.na (rowVec) %>% all (.))  return (NA)
                    not0  <-  which (rowVec != 0)    #  y signals
                    sta  <-  first (not0)  %>%  {if (. == 1)  1  else  . -1}    #  leave two 0 on the both sides in y signals
                    end  <-  last (not0)  %>%  {if (. == ncol (Ypsd))  ncol (Ypsd)  else  . +1}
                    if (cook)  tenta  <-  gamXY. (x = Xch [sta: end], y = rowVec [sta: end], boost = T, n.boost = 200)   #  200 ch interpolated
                    if (! cook)  tenta  <-  data.frame (x = Xch [sta: end], y = rowVec [sta: end])   #  or raw data if you want
                    return (tenta  %>%  freq2dens. (.) )
            }
            pmap (Ypsd, ~ pullRealValues (rowVec = c (...))) %>%  return (.)    #  = system.time ( map (Ypsd %>% t (.) %>% as_tibble (.), pullRealValues) )
    }

    ##  CSV reader for any data  ========================
    getCSV.  <-  function (...)  getData. (timeSort = F) %>%  psdLab. (.)  %>%  return (.)

    ##  Correct a PSD label which is interpreted as date  == (2019-05-10) ========================
    psdLab.  <-  function (dt, ... ) {
            dt <- dt %>% 'dplyr'::filter(rowSums(is.na(.)) != ncol(.)) 
            dt  <-  mutate_at (dt, 'ó±ìx', ~ gsub ('åé', '-', .) %>%  gsub ('ì˙', '', .)  %>%  gsub ('2001/2/3', '1/2-3', .))
            ten  <-  dt [['ë™íËì˙éû']]  %>%  {. [! is.na (.)] [1]}  %>%  str_count (., '/|:')
            if (type_sum (dt [['ë™íËì˙éû']]) != 'dttm' && nrow (dt) > 0) {
                   dt  <-  mutate_at (dt, 'ë™íËì˙éû', parse_date_time2, orders = whichSize. (ten, 2:4, c ('Ymd', 'YmdHM', 'YmdHMS')), tz = 'Asia/Tokyo')
            }
            return (dt)
    }

    ##  Error functions  ========================
    unitNorm  <-  function (x)  1 /sqrt (2 *pi) *exp (-x ^2 /2)
    erfc  <-  function (x)  2 *pnorm (x *sqrt (2), lower = F)    # https://stackoverflow.com/questions/29067916/error-function-erfz
    erfcx  <-  function (x)  exp (x ^2) *erfc (x)    #  Scaled complementary error function: https://en.wikipedia.org/wiki/Exponentially_modified_Gaussian_distribution
    stnorm  <-  function (x)  1 /sqrt (2 *pi) *exp (-1/2 *x ^2)    #  standard normal probability density function
    stcum  <-  function (x)  1/2 *(1 +erfc (x /sqrt (2)))    # cumulative distribution funciton

    ##  Amoroso distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    amoF.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (nu= 1, lam= 0.1, al= 10, be= 1), list (nu= sd (x *y), lam= sd (x *y), al= sd (x *y), be= sd (x *y)), list (nu= 1, lam= 1, al= 1, be= 1), list (nu= 10, lam= 1, al= 10, be= 0.1) )
            f  <-  function (x,nu,lam,al,be)  1 /gamma (al) *abs (be /lam) *((x -nu) /lam) ^(al *be -1) *exp (- ((x -nu) /lam) ^be)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    amoY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            1 /gamma (al) *abs (be /lam) *((x -nu) /lam) ^(al *be -1) *exp (- ((x -nu) /lam) ^be)  %>%  return (.)
    }

    ##  Benini distribution  == https://en.wikipedia.org/wiki/Benini_distribution ========================
    beniniF.  <-  function (x, y, ... ) {    #  (shape) al, be > 0, (scale) lam > 0
            pLL  <-  list ( list (lam = sd (x *y), al = sd (x *y), be = sd (x *y)) )
            f  <-  function (x,lam,al,be)  (al + 2 *be *log (x /lam)) /x *exp (- al *log (x /lam) - be *(log (x /lam)) ^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    beniniY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            (al + 2 *be *log (x /lam)) /x *exp (- al *log (x /lam) - be *(log (x /lam)) ^2)  %>%  return (.)
    }

    ##  Beta distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    betaF.  <-  function (x, y, ... ) {
            pLL  <-  list(list (nu=0.01,lam=1000,al=0.1,be=0.1), list (nu=0.1,lam=100,al=10,be=1), list (nu=0.01,lam=100,al=1,be=10), list (nu=0.01,lam=100,al=10,be=10))
            f  <-  function (x,nu,lam,al,be)  1 /beta (al,be) /abs (lam) *((x -nu) /lam) ^(al -1) *(1 -(x -nu) /lam) ^(be -1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    betaY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            1 /beta (al,be) /abs (lam) *((x -nu) /lam) ^(al -1) *(1 -(x -nu) /lam) ^(be -1)  %>%  return (.)
    }

    ##  Beta Prime distribution  == https://en.wikipedia.org/wiki/Beta_prime_distribution ========================
    betaPrimeF.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (nu = 1, lam = 1, al = sd (x *y), be = sd (x *y)), list (nu = 0.1, lam = 1, al = 1, be = 1), list (nu = 0.1, lam = 1, al = 10, be = 10) )
            f  <-  function (x,nu,lam,al,be)  1 /beta (al,be) *((x -nu) /lam) ^(al -1) *(1 +(x -nu) /lam) ^(-al -be)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    betaPrimeY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            1 /beta (al,be) *((x -nu) /lam) ^(al -1) *(1 +(x -nu) /lam) ^(-al -be)  %>%  return (.)
    }

    ##  BHP (Bramwell-Holdsworth-Pinton) distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ==
    bhpF.  <-  function (x, y, ... ) {    #  similar to exGamma, gGumbel, Gumbel, BHP; (positive integer) n
            pLL  <-  list ( list (nu = 10, lam = 1), list (nu = 10, lam = 10) )
            f  <-  function (x,nu,lam)  1 /gamma (pi /2) /abs (lam) *exp (pi /2 *(x -nu) /lam -exp ((x -nu) /lam))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    bhpY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            1 /gamma (pi /2) /abs (lam) *exp (pi /2 *(x -nu) /lam -exp ((x -nu) /lam))  %>%  return (.)
    }

    ##  Burr type VIII distribution  == https://github.com/cran/propagate/blob/master/R/distr-densities.R ========================
    burr8F.  <-  function (x, y, ... ) {    #  (shape) al > 0
            pLL  <-  list ( list (al = sd (x *y)) )
            f  <-  function (x,al)  al *(pi /2) ^(-al) *1 /(exp (x) +exp (-x)) *(atan (exp (x))) ^(al -1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    burr8Y.  <-  function (mdl, x, ... ) {
            def. (c ('al'), list (coef (mdl) [1] ))
            al *(pi /2) ^(-al) *1 /(exp (x) +exp (-x)) *(atan (exp (x))) ^(al -1)  %>%  return (.)
    }

    ##  Burr type XII distribution  == https://en.wikipedia.org/wiki/Burr_distribution ========================
    burr12F.  <-  function (x, y, ... ) {    #  al, be > 0, (scale) lam > 0;  similar to Singh-Maddala (nu ÅÇ 0)
            pLL  <-  list ( list (lam = sd (x *y), al = sd (x *y), be = sd (x *y)), list (lam = 10, al = sd (x *y), be = sd (x *y)) )
            f  <-  function (x,lam,al,be)  abs (al *be /lam) *(x /lam) ^(al -1) *(1 + (x /lam) ^al) ^(-be -1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    burr12Y.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            abs (al *be /lam) *(x /lam) ^(al -1) *(1 + (x /lam) ^al) ^(-be -1)  %>%  return (.)
    }

    ##  Cauchy distribution  == https://en.wikipedia.org/wiki/Cauchy_distribution ========================
    cauchyF.  <-  function (x, y, ... ) {    #  (location) mu, (scale) lam > 0; similar to Pearson VII, Cauchy, RBW, and Student's t
            pLL  <-  list ( list (nu = sd (x *y), lam = sd (x *y)), list (nu = 10, lam = 1) )
            f  <-  function (x,nu,lam)  1 /pi /lam /(1 +((x -nu) /lam) ^2) ^(-1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    cauchyY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            1 /pi /lam /(1 +((x -nu) /lam) ^2) ^(-1)  %>% return (.)
    }

    ##  Chi distribution  == http://www.ntrand.com/jp/chi-distribution/ ========================
    chiF.  <-  function (x, y, ... ) {    #  (degrees of freedom) n >0, x >= 0
            pLL  <-  list ( list (n = sd (x *y)) )
            f  <-  function (x,n)  2 ^(-n /2 +1) /gamma (n /2) *x ^(n -1) *exp (-x ^2 /2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,n), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    chiY.  <-  function (mdl, x, ... ) {
            def. (c ('n'), list (coef (mdl) [1] ))
            2 ^(-n /2 +1) /gamma (n /2) *x ^(n -1) *exp (-x ^2 /2)  %>%  return (.)
    }

    ##  Dagum distribution  == https://en.wikipedia.org/wiki/Dagum_distribution ========================
    dagumF.  <-  function (x, y, ... ) {    #  (shape) al, be > 0, (scale) lam > 0; aka inverse Burr distribution (type III)
            pLL  <-  list ( list (lam = sd (x *y), al = sd (x *y), be = sd (x *y)), list (lam = 1, al = 1, be = 100) )
            f  <-  function (x,lam,al,be)  al *be /lam *(x /lam) ^(al *be -1) *( (x /lam) ^al +1 ) ^(-be -1)    #  Don't use abs (al*be/lam) due to lower AIC?
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    dagumY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            al *be /lam *(x /lam) ^(al *be -1) *( (x /lam) ^al +1 ) ^(-be -1)  %>%  return (.)
    }

    dagum2F.  <-  function (x, y, ... ) {    #  My idea and it improves the original slightly, but cannnot defeat gbp or gb2 ...
            pL  <-  list (    #  data.frame (    #  Let it confirm whether each element number is the same.
                    nu = c (1, 1, 1, 1, 10, 10, 10, 1, 1, 0.1, 10, 1, sd (x *y), 1, 0, 0),
                    lam = c (1, 10, 10, 10, 1, 10, 10, 1, 10, 1, 10, 0.1, sd (x *y), sd (x *y), sd (x *y), 1),
                    al = c (1, 10, 1, 0.1, 0.1, 1, 10, 1, 1, 1, 1, 1, sd (x *y), sd (x *y), sd (x *y), 1),
                    be = c (1, 1, 1, 0.1, 0.1, 0.1, 1, 0.1, 1, 0.1, 1, 0.1, sd (x *y), sd (x *y),sd (x *y), 100)
            )
            f  <-  function (x,nu,lam,al,be)  al *be /lam *((x -nu) /lam) ^(al *be -1) *(1 +((x -nu) /lam) ^al) ^(-be -1)    # Don't use abs (al*be/lam) due to lower AIC.
            mL  <-  list ()
            for (i in seq_along (pL $ 'nu'))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,be), start = lapply (pL, '[', i)) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
#          map. (dL, ~ dagum2F. (. $ 'x', . $ 'y') %>% aic. (.))  %>%  boxplot (.)
#          abline (h = -1860)
    dagum2Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            al *be /lam *((x -nu) /lam) ^(al *be -1) *(1 +((x -nu) /lam) ^al) ^(-be -1)  %>%  return (.)
    }

    ##  Exponentially Beta distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    exBetaF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam > 0, (shape) al, ga > 0; similar to Prentice, exBeta, and Logistic
            pLL  <-  list ( list (nu=0.01,lam=1,al=1,ga=1e3), list (nu=0.01,lam=1,al=1,ga=1e4), list (nu=0.1,lam=1,al=1,ga=1e3), list (nu=0.01,lam=1,al=1,ga=10) )
            f  <-  function (x,nu,lam,al,ga)  1 /beta (al,ga) /abs (lam) *exp (-al *(x -nu) /lam) *(1 -exp (-(x -nu) /lam)) ^(ga -1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,ga), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    exBetaY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'ga'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            1 /beta (al,ga) /abs (lam) *exp (-al *(x -nu) /lam) *(1 -exp (-(x -nu) /lam)) ^(ga -1)  %>%  return (.)
    }

    ##  Exponentially Gamma distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ==
    exGammaF.  <-  function (x, y, ... ) {    #  similar to exGamma, gGumbel, Gumbel, BHP;  heavy tail on the left
            pLL  <-  list ( list (nu = x [which.max (y)], lam = sd (x *y), al = sd (x *y)), list (nu = 10, lam = 0.1, al = 1), list (nu = 10, lam = 10, al = 10) )
            f  <-  function (x,nu,lam,al)  1 /gamma (al) /abs (lam) *exp (al *(x -nu) /lam -exp ((x -nu) /lam))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    exGammaY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1 /gamma (al) /abs (lam) *exp (al *(x -nu) /lam -exp ((x -nu) /lam))  %>%  return (.)
    }

    ##  Exponentially Generalized Beta distribution  == https://en.wikipedia.org/wiki/Generalized_beta_distribution ========================
    exGenBetaF.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (nu=1,lam=1,al=1,be=1,ga=1),list (nu=1,lam=1,al=1,be=1,ga=0.1),list (nu=10,lam=1,al=1,be=1,ga=0.1) )
            f  <-  function (x,nu,lam,al,be,ga)  1/beta(al,ga) /abs (lam) *exp(al *(x-nu)/lam) *(1 -(1 -be) *exp ((x-nu)/lam)) ^(ga -1) *(1 +be *exp ((x-nu)/lam)) ^(-al-ga)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,be,ga), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    exGenBetaY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'be', 'ga'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4], coef (mdl) [5] ))
            1/beta(al,ga) /abs (lam) *exp(al *(x-nu)/lam) *(1 -(1 -be) *exp ((x-nu)/lam)) ^(ga -1) *(1 +be *exp ((x-nu)/lam)) ^(-al-ga)  %>%  return (.)
    }

    ##  Expotentially modified Gaussian distribution  == https://en.wikipedia.org/wiki/Exponentially_modified_Gaussian_distribution ==
    exGauss3F.  <-  function (x, y, ... ) {    #  avg := É +É—, var := É–^2 +É—^2
            pLL  <-  list ( list (mu = x [which.max. (y)], sig = 1, tau = 1) )
            f  <-  function (x,mu,sig,tau)  tau /2 *exp (tau * (mu +tau *sig ^2 /2 -x)) * erfc ((mu +tau *sig ^2 -x) /sqrt (2) /sig)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,mu,sig,tau), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    exGauss3Y.  <-  function (mdl, x, ... ) {
            def. (c ('mu', 'sig', 'tau'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            tau /2 *exp (tau * (mu +tau *sig ^2 /2 -x)) * erfc ((mu +tau *sig ^2 -x) /sqrt (2) /sig)  %>%  return (.)
    }

    exGauss4F.  <-  function (x, y, ... ) {    #  avg := É +É—, var := É–^2 +É—^2
            pLL  <-  list ( list (mu = x [which.max. (y)], sig = 1, tau = 1, h = 1) )
            f  <-  function (x,mu,sig,tau,h)  h *sig /tau *sqrt (pi /2) *exp (1/2 *(sig /tau) ^2 - (x -mu) /tau) *erfc (1 /sqrt (2) *(sig /tau - (x -mu) /sig))
#          f  <-  function (x,mu,sig,tau,h)  h *exp (-1/2 *((x -mu) /sig) ^2) *sig /tau *sqrt (pi /2) *erfcx ( 1 /sqrt (2) *(sig /tau - (x -mu) /sig))    #  the same
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,mu,sig,tau,h), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    exGauss4Y.  <-  function (mdl, x, ... ) {
            def. (c ('mu', 'sig', 'tau', 'h'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            h *sig /tau *sqrt (pi /2) *exp (1/2 *(sig /tau) ^2 - (x -mu) /tau) *erfc (1 /sqrt (2) *(sig /tau - (x -mu) /sig)) %>%  return (.)
    }

    ##  Exponentially Power distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ==
    exPowerF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam > 0, (power) be
            pLL  <-  list ( list (nu = x [which.max (y)], lam = sd (x *y), be = sd (x *y)), list (nu = 0.1, lam = 1, be = 10) )
            f  <-  function (x,nu,lam,be)  be /2 /lam /gamma (1 /be) *exp (-abs ((x -nu) /lam) ^be)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    exPowerY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            be /2 /lam /gamma (1 /be) *exp (-abs ((x -nu) /lam) ^be)  %>%  return (.)
    }

    ##  Fatigue Life distribution  == https://www.vosesoftware.com/riskwiki/FatigueLifedistribution.php ========================
    fatigueF.  <-  function (x, y, ... ) {    #  (domain) x > nu > 0,  lam, al > 0
            pLL  <-  list ( list (nu = sd (x *y), lam = sd (x *y), al = 100), list (nu = 0.1, lam = 100, al = 100) )
            z  <-  function (x,nu,lam)  sqrt ((x -nu) /lam)
            f  <-  function (x,nu,lam,al)  (z (x,nu,lam) +1 /z (x,nu,lam)) /2 /al /z (x,nu,lam) ^2 *unitNorm ((z (x,nu,lam) +1 /z (x,nu,lam)) /al)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    fatigueY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            z  <-  function (x,nu,lam)  sqrt ((x -nu) /lam)
            (z (x,nu,lam) +1 /z (x,nu,lam)) /2 /al /z (x,nu,lam) ^2 *unitNorm ((z (x,nu,lam) +1 /z (x,nu,lam)) /al)  %>%  return (.)
    }

    ##  Four-parameter Beta distribution  == https://www.vosesoftware.com/riskwiki/Beta4distribution.php ========================
    beta4F.  <-  function (x, y, ... ) {    #  (shape) j > 0, (shape) k > 0, (min) mi, (max) ma,
            pLL  <-  list ( list (j = 10, k = 10, mi = min (x), ma = max (x)), list (j = 1, k = 10, mi = 0, ma = 1e4), list (j = 0.1, k = 0.1, mi = 0, ma = 1e4) )
            f  <-  function (x,j,k,mi,ma)  1 /beta (j,k) *(x -mi) ^(j -1) *(ma -x) ^(k -1) /(ma -mi) ^(j +k -1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,j,k,mi,ma), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    beta4Y.  <-  function (mdl, x, ... ) {
            def. (c ('j', 'k', 'mi', 'ma'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            1 /beta (j,k) *(x -mi) ^(j -1) *(ma -x) ^(k -1) /(ma -mi) ^(j +k -1)  %>%  return (.)
    }

    ##  Four-parameter Kumaraswamy distribution  == https://www.vosesoftware.com/riskwiki/Kumaraswamy4distribution.php ========================
    kuma4F.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (j=10, k =10, mi=0, ma=1e3), list (j=1, k= 1, mi=0, ma=1e3), list (j=x[which.max(y)], k= x[which.max(y)], mi=0, ma=1e3)  )
            z  <-  function (x,mi,ma)  sqrt ((x -mi) /(ma -mi))
            f  <-  function (x,j,k,mi,ma)  j *k *z (x,mi,ma) ^(j -1) *(1 -z (x,mi,ma) ^j) ^(k -1) /(ma -mi)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,j,k,mi,ma), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    kuma4Y.  <-  function (mdl, x, ... ) {
            def. (c ('j', 'k', 'mi', 'ma'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            z  <-  function (x,mi,ma)  sqrt ((x -mi) /(ma -mi))
            j *k *z (x,mi,ma) ^(j -1) *(1 -z (x,mi,ma) ^j) ^(k -1) /(ma -mi)  %>%  return (.)
    }

    ##  Frechet distribution  == https://en.wikipedia.org/wiki/Frechet_distribution ========================
    frechetF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam > 0, (shape) al > 0
            pLL  <-  list ( list (nu = sd (x *y), lam = sd (x *y), al = sd (x *y)), list (nu = 1, lam = 0.01, al = 10) )
            f  <-  function (x,nu,lam,al)  al /lam *(lam / (x -nu)) ^(al +1) *exp (- (lam / (x -nu)) ^al)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    frechetY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            al /lam *(lam / (x -nu)) ^(al +1) *exp (- (lam / (x -nu)) ^al)  %>%  return (.)
    }

    ##  Gamma distribution  == https://en.wikipedia.org/wiki/Gamma_distribution  == http://nhkuma.blogspot.com/2013/08/blog-post_13.html  ==
    gammaF.  <-  function (x, y, ... ) {    #  (scale) lam > 0, (shape) al > 0;  x --> x -nu becomes Pearson III
            pLL  <-  list ( list (lam = sd (x *y), al = sd (x *y)), list (lam = 1, al = 1), list (lam = 1, al = 10) )
            f  <-  function (x,lam,al)  1 /gamma (al) /abs (lam) *(x /lam) ^(al -1) *exp (-x /lam)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gammaY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al'), list (coef (mdl) [1], coef (mdl) [2] ))
            1 /gamma (al) /abs (lam) *(x /lam) ^(al -1) *exp (-x /lam)  %>%  return (.)
    }

    ##  Generalized Beta Prime distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    gbpF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam > 0, (shape) al, be, ga > 0
            pLL  <-  list ( list (nu=0.1,lam=1,al=1,be=1,ga=1), list (nu=0.1,lam=10,al=1,be=1,ga=10), list (nu=0.01,lam=10,al=1,be=1,ga=1), list (nu=1,lam=1,al=1,be=1,ga=1),  list (nu=0.1,lam=10,al=1,be=1,ga=1), list (nu=0.1,lam=0.1,al=0.1,be=0.1,ga=0.1), list (nu=1,lam=0.1,al=0.1,be=0.1,ga=0.1) )
            f  <-  function (x,nu,lam,al,be,ga)  1 /beta (al,ga) *abs (be /lam) *((x -nu) /lam) ^(al *be -1) *(1 +((x -nu) /lam) ^be) ^(-al -ga)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,be,ga), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
#            map. (dL, ~ gbpF. (. $ 'x', . $ 'y') %>% aic. (.))  %>%  boxplot (.)
    gbpY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'be', 'ga'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4], coef (mdl) [5] ))
            1 /beta (al,ga) *abs (be /lam) *((x -nu) /lam) ^(al *be -1) *(1 +((x -nu) /lam) ^be) ^(-al -ga)  %>%  return (.)
    }

    ##  Generalized Beta of the second kind distribution  == https://en.wikipedia.org/wiki/Generalized_beta_distribution  ==
   gb2F.  <-  function (x, y, ... ) {    #  (scale) lam > 0, (shape) al, be, ga > 0;  almost the same to gbp
            pLL  <-  list ( list (lam = sd (x *y), al = sd (x *y), be = sd (x *y), ga = 1) )
            f  <-  function (x,lam,al,be,ga)  1 /beta (al,ga) *abs (be /lam) *(x /lam) ^(al *be -1) *(1 +(x /lam) ^be) ^(-al -ga)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al,be,ga), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gb2Y.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al', 'be', 'ga'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            1 /beta (al,ga) *abs (be /lam) *(x /lam) ^(al *be -1) *(1 +(x /lam) ^be) ^(-al -ga)  %>%  return (.)
    }

    ##  Generalized Fisher-Tippett distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ==
    gftF.  <-  function (x, y, ... ) {    #  similar to gGumbel
            pLL  <-  list ( list (nu=0.01, lam=1, n=1, be=1), list (nu=0.01, lam=100, n=1, be=1), list (nu=0.01, lam=100, n=10, be=1), list (nu=0.1, lam=1000, n=1, be=1) )
            f  <-  function (x,nu,lam,n,be)  n ^n /gamma (n) *abs (be /lam) *((x -nu) /lam) ^(n *be -1) *exp (-n *((x -nu) /lam) ^be)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,n,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gftY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'n', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            n ^n /gamma (n) *abs (be /lam) *((x -nu) /lam) ^(n *be -1) *exp (-n *((x -nu) /lam) ^be)  %>%  return (.)
    }

    ##  Generalized Gamma distribution  == https://en.wikipedia.org/wiki/Generalized_gamma_distribution  ==
   gGammaF.  <-  function (x, y, ... ) {    #  (scale) lam > 0, if al = be it becomes Weibull
            pLL  <-  list ( list (lam = 1, al = 1, be = 1), list (lam = 10, al = 0.1, be = 1) )
            f  <-  function (x,lam,al,be)  1 /gamma (al /be) *abs (be /lam) *(x /lam) ^(al -1) *exp (-(x /lam) ^be)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gGammaY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1 /gamma (al /be) *abs (be /lam) *(x /lam) ^(al -1) *exp (-(x /lam) ^be)  %>%  return (.)
    }

    ##  Generalized Gumbel distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ==
    gGumbelF.  <-  function (x, y, ... ) {    #  similar to exGamma, gGumbel, Gumbel, BHP; (positive integer) n
            pLL  <-  list ( list (nu = 10, lam = 1, n = 1), list (nu = 10, lam = 10, n = 1) )
            f  <-  function (x,nu,lam,n)  n ^n /gamma (n) /abs (lam) *exp (-n *(x -nu) /lam -n *exp ((x -nu) /lam))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,n), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gGumbelY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'n'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            n ^n /gamma (n) /abs (lam) *exp (-n *(x -nu) /lam -n *exp ((x -nu) /lam))  %>%  return (.)
    }

    ##  Generalized Inverse Gaussian distribution  == https://en.wikipedia.org/wiki/Generalized_inverse_Gaussian_distribution ==  https://github.com/JuliaStats/Distributions.jl/issues/554  ==
   gigF.  <-  function (x, y, ... ) {    #  Using modified Bessel function of the second kind;  NOTE:  I've reshaped the formula in Wiki as a = alpha /lambda, b = beta *lambda
            pLL  <-  list ( list (lam = sd (x *y), al = sd (x *y), be = sd (x *y)), list (lam = 1, al = 1, be = 1), list (lam = 10, al = 1, be = 0.1) )
            f  <-  function (x,lam,al,be)  1/besselK (al, be) *abs ( 1/2 /lam) *(x /lam) ^(al -1) * exp (-be /2 * (x /lam +lam /x))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gigY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1/besselK (al, be) *abs ( 1/2 /lam) *(x /lam) ^(al -1) * exp (-be /2 * (x /lam +lam /x))  %>%  return (.)
    }

    ##  Generalized Normal ver.1 distribution  == https://en.wikipedia.org/wiki/Generalized_normal_distribution  ==
   gn1F.  <-  function (x, y, ... ) {    #  a, b > 0 , p in R
            pLL  <-  list ( list (nu = x [which.max (y)], lam = sd (x *y), al = sd (x *y)) )
            f  <-  function (x,nu,lam,al)  1/gamma (1 /al) *abs (al /2 /lam) *exp (- abs ((x -nu) /lam) ^al)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gn1Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1/gamma (1 /al) *abs (al /2 /lam) *exp (- abs ((x -nu) /lam) ^al)  %>%  return (.)
    }

    ##  Generalized Normal ver.2 distribution  == https://en.wikipedia.org/wiki/Generalized_normal_distribution  ==
   gn2F.  <-  function (x, y, ... ) {    #  (location) nu in R, (shape) al in R, (scale) lam > 0
            pLL  <-  list ( list (nu = x [which.max (y)], lam = x [which.max (y)], al = sd (x *y)), list (nu = 10, lam = 0.1, al = 0.1) )
            z  <-  function (x,nu,lam,al)  if (al != 0)  (x -nu) /lam  else  -1 /al *log (1 -al *(x -nu) /lam)
            f  <-  function (x,nu,lam,al)  stnorm (z (x,nu,lam,al)) /(lam -al *(x -nu))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gn2Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            z  <-  function (x,nu,lam,al)  if (al != 0)  (x -nu) /lam  else  -1 /al *log (1 -al *(x -nu) /lam)
            stnorm (z (x,nu,lam,al)) /(lam -al *(x -nu))  %>% return (.)
    }

    ##  Generalized Pearson VII distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ==
    gPearson7F.  <-  function (x, y, ... ) {    # be, m > 0, be *m > 1
            pLL  <-  list ( list (nu = 10, lam = 1, al = 1, m = 1), list (nu = 100, lam = 1, al = 1, m = 1) )
            f  <-  function (x,nu,lam,al,m)  1 /beta (m -1 /al, 1 /al) *abs (al /2 /lam) *(1 +abs ((x -nu) /lam) ^al) ^(-m)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,m), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gPearson7Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'm'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            1 /beta (m -1 /al, 1 /al) *abs (al /2 /lam) *(1 +abs ((x -nu) /lam) ^al) ^(-m)  %>%  return (.)
    }

    ##  Gumbel distribution  == https://en.wikipedia.org/wiki/Gumbel_distribution ========================
    gumbelF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam > 0
            pLL  <-  list ( list (nu = sd (x *y), lam = sd (x *y)) )
            f  <-  function (x,nu,lam)  1/abs (lam) *exp (- (x -nu) /lam -exp (- (x -nu) /lam))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    gumbelY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            1/abs (lam) *exp (- (x -nu) /lam -exp (- (x -nu) /lam))  %>%  return (.)
    }

    ##  Inverse Chi distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    invChiF.  <-  function (x, y, ... ) {    #  (degrees of freedom) j >0, x >= 0
            pLL  <-  list ( list (n = sd (x *y)) )
            f  <-  function (x,n)  2 *sqrt (2) /gamma (n /2) *(1/sqrt (2) /x) ^(n +1) *exp (-1/2 /x ^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,n), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    invChiY.  <-  function (mdl, x, ... ) {
            def. (c ('n'), list (coef (mdl) [1] ))
            2 *sqrt (2) /gamma (n /2) *(1/sqrt (2) /x) ^(n +1) *exp (-1/2 /x ^2)  %>%  return (.)
    }

    ##  Inverse Gamma distribution  == https://en.wikipedia.org/wiki/Inverse-gamma_distribution ========================
    invGammaF.  <-  function (x, y, ... ) {    #  (shape) k > 0, (scale) lam > 0
            pLL  <-  list ( list (lam = 1, al = 1) )    # Never set lam = al = sd (x *y):  Its AIC increases twice.
            f  <-  function (x,lam,al)  1 /gamma (al) /abs (lam) *(lam /x) ^(al +1) *exp (-lam /x)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    invGammaY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al'), list (coef (mdl) [1], coef (mdl) [2] ))
            1 /gamma (al) /abs (lam) *(lam /x) ^(al +1) *exp (-lam /x)  %>%  return (.)
    }

    ##  Inverse Gaussian (Wald) distribution  == https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution ========================
    invGaussF.  <-  function (x, y, ... ) {    #  (location) nu > 0, (shape) k > 0;  aka Wald
            pLL  <-  list ( list (nu = 10, lam = 1) )
            f  <-  function (x,nu,lam)  sqrt (lam /2 /pi /x ^3) *exp (-lam *(x -nu)^2 /2 /nu^2 /x)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    invGaussY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            sqrt (lam /2 /pi /x ^3) *exp (-lam *(x -nu)^2 /2 /nu^2 /x)  %>%  return (.)
    }

    ##  Inverse Rayleigh distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    invRayleighF.  <-  function (x, y, ... ) {    #  My modification, x --> x -nu
            pLL  <-  list ( list (nu = 1, lam = sd (x *y)), list (nu = 0.1, lam = sd (x *y)) )
            f  <-  function (x,nu,lam)  2 *sqrt (2 *lam ^2) * (1 /sqrt (2 *lam ^2) /(x -nu)) ^3 *exp (-1/2 /lam ^2 /(x -nu) ^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    invRayleighY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            2 *sqrt (2 *lam ^2) * (1 /sqrt (2 *lam ^2) /(x -nu)) ^3 *exp (-1/2 /lam ^2 /(x -nu) ^2)  %>%  return (.)
    }

    ##  Johnson's SB distribution  == https://www.vosesoftware.com/riskwiki/JohnsonBdistribution.php ========================
    jsbF.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (j=0.1, k=0.01, mi=0.1, ma=1e4), list (j=0.01, k=1, mi=1, ma=1e4), list (j=1, k=1, mi=1, ma=1e2), list (j=10, k=1, mi=1, ma=1e3) )
            f  <-  function (x,j,k,mi,ma)  k *(ma -mi) /(x -mi) /(ma -x) /sqrt (2 *pi) *exp (-1/2 *(j +k *log ((x -mi) /(ma -x)))^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,j,k,mi,ma), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    jsbY.  <-  function (mdl, x, ... ) {
            def. (c ('j', 'k', 'mi', 'ma'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            k *(ma -mi) /(x -mi) /(ma -x) /sqrt (2 *pi) *exp (-1/2 *(j +k *log ((x -mi) /(ma -x)))^2)  %>%  return (.)
    }

    ##  Johnson's SU distribution  == https://en.wikipedia.org/wiki/Johnson%27s_SU-distribution  == https://cran.r-project.org/web/packages/SuppDists/SuppDists.pdf ==  http://www.ntrand.com/jp/johnson-su-distribution/ ====================
    jsuF.  <-  function (x, y, ... ) {    #  nu, lam, al, be > 0; S"U" denotes an "U"nbounded distribution
            pLL  <-  list ( list (nu=1,lam=1,al=1,be=1), list (nu=10,lam=1,al=1,be=1) )    #  Never set def. (c ('xi', 'lam'), list (sd (x *y), sd (x *y))):  Its AIC increases twice.
            f  <-  function (x,nu,lam,al,be)  be *(1 +((x -nu) /lam) ^2) ^(-1/2) /sqrt (2 *pi *lam ^2) *exp (-1/2 *(al +be *asinh ((x -nu) /lam)) ^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    jsuY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            be *(1 +((x -nu) /lam) ^2) ^(-1/2) /sqrt (2 *pi *lam ^2) *exp (-1/2 *(al +be *asinh ((x -nu) /lam)) ^2)  %>%  return (.)
    }

    ##  Levy distribution  == https://en.wikipedia.org/wiki/Levy_distribution ========================
    levyF.  <-  function (x, y, ... ) {    #  Cliff-like on left side; (location) nu, (scale) lam > 0
            pLL  <-  list ( list (nu = sd (x *y), lam = sd (x *y)), list (nu = 1, lam = 1), list (nu = 0.1, lam = 1) )
            f  <-  function (x,nu,lam)  sqrt (lam /2 /pi) /(x -nu) ^(3/2) *exp (-lam /2 /(x -nu))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    levyY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            sqrt (lam /2 /pi) /(x -nu) ^(3/2) *exp (-lam /2 /(x -nu))  %>%  return (.)
    }

    ##  Logistic distribution  == https://en.wikipedia.org/wiki/Logistic_distribution ========================
    logisF.  <-  function (x, y, ... ) {    #  (location) nu in R, (scale) lam > 0; similar to Prentice, exBeta, and Logistic
            pLL  <-  list ( list (nu = 10, lam = 1) )    # Never set def. (c ('mu', 'lam'), list (sd (x * y), sd (x * y))): Its AIC increases twice.
            f  <-  function (x,nu,lam)  abs (1 /lam) *exp (- (x -nu) /lam) *(1 +exp (- (x -nu) /lam)) ^(-2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    logisY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            abs (1 /lam) *exp (- (x -nu) /lam) *(1 +exp (- (x -nu) /lam)) ^(-2)  %>%  return (.)
    }

    ##  Log-Gamma distribution  == https://link.springer.com/article/10.1007%2FBF02922944 ========================
    logGamF.  <-  function (x, y, ... ) {    #  CAUTION !! It's diffrent from many web sites;  heavy tail on the left
            pLL  <-  list ( list (nu = log (x [which.max (y)]), al=10,be=10), list (nu=0,al=10,be=10), list (nu=0,al=10,be=1), list (nu=log(sd(x*y)),al=0.1,be=0) )
            f  <-  function (x,nu,al,be)  be ^al /gamma (al) *(x -nu) ^(-be -1) *(log (x -nu)) ^(al -1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    logGamY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            be ^al /gamma (al) *(x -nu) ^(-be -1) *(log (x -nu)) ^(al -1)  %>%  return (.)
    }

    ##  Log-Logistic distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    logLogF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam > 0, (shape) be > 0
            pLL  <-  list( list(nu=0.01,lam=1,al=1), list(nu=0.01,lam=100,al=1), list(nu=0.01,lam=100,al=1), list(nu=0.1,lam=1000,al=1),
                       list(nu=1,lam=10,al=1), list(nu=1,lam=10,al=0.1), list(nu=0.1,lam=0.1,al=0.1), list(nu=0.1,lam=1,al=1),
                       list(nu=1,lam=1,al=1), list(nu=10,lam=1,al=10), list(nu=10,lam=10,al=1) ) 
            f  <-  function (x,nu,lam,al)  abs (al /lam) *((x -nu) /lam) ^(al -1) *(1 + ((x -nu) /lam) ^al) ^(-2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    logLogY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            abs (al /lam) *((x -nu) /lam) ^(al -1) *(1 + ((x -nu) /lam) ^al) ^(-2)  %>%  return (.)
    }

    ##  Log-Normal distribution  == https://en.wikipedia.org/wiki/Log-normal_distribution ========================
    logNormF.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (mu = 1, sig = 1) )
            f  <-  function (x,mu,sig)  1/x /sqrt (2 *pi) /sig *exp (-1/2 * ( (log (x) -mu) /sig ) ^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,mu,sig), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    logNormY.  <-  function (mdl, x, ... ) {
            def. (c ('mu', 'sig'), list (coef (mdl) [1], coef (mdl) [2] ))
            1/x /sqrt (2 *pi) /sig *exp (-1/2 * ( (log (x) -mu) /sig ) ^2)  %>%  return (.)
    }

    ##  Nakagami distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    nakagamiF.  <-  function (x, y, ... ) {    #  Wiki's parameter m/É∂ = É…^2
            pLL <-list(list(nu=1,lam=1,m=10),list(nu=10,lam=10,m=10),list(nu=0.1,lam=10,m=1),list(nu=1,lam=10,m=1),list(nu=1,lam=10,m=10))
            f  <-  function (x,nu,lam,m)  2 /gamma (m) /abs (lam) *((x -nu) /lam) ^(2*m -1) *exp (-((x-nu) /lam) ^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,m), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    nakagamiY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'm'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            2 /gamma (m) /abs (lam) *((x -nu) /lam) ^(2*m -1) *exp (-((x-nu) /lam) ^2)  %>%  return (.)
    }

    ##  Normal distribution  == https://en.wikipedia.org/wiki/Normal_distribution ========================
    normF.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (mu = x [which.max. (y)], sig = 1) )
            f  <-  function (x,mu,sig)  1 /sqrt (2 *pi) /sig *exp (-1/2 *((x -mu) /sig) ^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,mu,sig), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    normY.  <-  function (mdl, x, ... ) {
            def. (c ('mu', 'sig'), list (coef (mdl) [1], coef (mdl) [2] ))
            1 /sqrt (2 *pi) /sig *exp (-1/2 *((x -mu) /sig) ^2) %>%  return (.)
    }

    ##  Nukiyama-Tanasawa distribution  == https://www.ugr.es/~fcamacho/Originales/Trabajos%20Publicados/PT_2008.pdf ========================
   nukiF.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (lam = 1, al = 1, be = 1), list (lam = sd (x *y), al = sd (x *y), be = sd (x *y)) )
            f  <-  function (x,lam,al,be)  1 /gamma (al /be) *abs (be /lam) *(x /lam) ^(al -1) *exp (-(x /lam) ^be)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    nukiY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1 /gamma (al /be) *abs (be /lam) *(x /lam) ^(al -1) *exp (-(x /lam) ^be)  %>%  return (.)
    }

    ##  Pearson III distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    pearson3F.  <-  function (x, y, ... ) {    #  (shape) k > 0 , (scale) lam > 0, x -nu --> x becomes Gamma
            pLL  <-  list ( list (nu = sd (x *y), lam = sd (x *y), al = sd (x *y)), list (nu = 1, lam = 1, al = 10), list (nu = 0.1, lam = 1, al = 1), list (nu = 0.1, lam = 10, al = 10) )
            f  <-  function (x,nu,lam,al)  1 /gamma (al) *abs (1 /lam) *((x -nu) /lam) ^(al -1) *exp (-(x -nu) /lam)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    pearson3Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1 /gamma (al) /abs (lam) *((x -nu) /lam) ^(al -1) *exp (-(x -nu) /lam)  %>%  return (.)
    }

    ##  Pearson V distribution  == https://www.vosesoftware.com/riskwiki/PearsonType5distribution.php == https://www.math.kyoto-u.ac.jp/~ichiro/2016Kyushu_abstract.pdf ========================
    pearson5F.  <-  function (x, y, ... ) {    #  PearsonV (nu =0) = Inverse Gamma (?)
            pLL  <-  list ( list (nu = 1, lam = 10, al = 10), list (nu = 0.1, lam = 10, al = 10), list (nu = 1, lam = 10, al = 1) )
            f  <-  function (x,nu,lam,al)  1 /gamma (al) /abs (lam) *(lam /(x -nu)) ^(al +1) *exp (-lam /(x -nu))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    pearson5Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1 /gamma (al) /abs (lam) *(lam /(x -nu)) ^(al +1) *exp (-lam /(x -nu))  %>%  return (.)
    }

    ##  Pearson VI distribution  == https://www.vosesoftware.com/riskwiki/PearsonType6distribution.php ========================
    pearson6F.  <-  function (x, y, ... ) {    #  PesonVI = Beta prime, F
            pLL  <-  list ( list (lam = 1, al = 0.1, ga = 1), list (lam = 1, al = 0.1, ga = 10) )
            f  <-  function (x,lam,al,ga)  1/beta (al,ga)  *abs (1 /lam) *(x /lam) ^(al -1) *(1 +x /lam) ^(-al -ga)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al,ga), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    pearson6Y.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al', 'ga'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1/beta (al,ga)  *abs (1 /lam) *(x /lam) ^(al -1) *(1 +x /lam) ^(-al -ga)  %>%  return (.)
    }

    ##  Pearson VII distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    pearson7F.  <-  function (x, y, ... ) {    # m > 1/2; similar to Pearson VII, Cauchy, RBW, and Student's t
            pLL  <-  list ( list (nu = 0.1, lam = 1, m = 1), list (nu = 0.1, lam = 10, m = 1) )
            f  <-  function (x,nu,lam,m)  1/beta (m,m-1/2) *abs (1 /lam) *(1 +((x -nu) /lam) ^2) ^(-m)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,m), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    pearson7Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'm'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1/beta (m,m-1/2) *abs (1 /lam) *(1 +((x -nu) /lam) ^2) ^(-m)  %>%  return (.)
    }

    ##  PERT (Program Evaluation and Review Technique) distribution  ==  https://en.wikipedia.org/wiki/PERT_distribution ========================
    pertF.  <-  function (x, y, ... ) {    #  al < be < gam; mu = (al + 4*be + ga) /6; It's a transformation of beta dist. as 4 parameters.
            pLL  <-  list ( list (al = 0.1, be = x [which.max. (y)], ga = max (x)) )    #  min, mode, max
            z1  <-  function (al,be,ga)  1 +4 *(be -al) /(ga -al)
            z2  <-  function (al,be,ga)  1 +4 *(ga -be) /(ga -al)
            f  <-  function (x,al,be,ga)  (x -al) ^(z1 (al,be,ga) -1) *(ga -x) ^(z2 (al,be,ga) -1) /beta (z1 (al,be,ga), z2 (al,be,ga)) /(ga -al) ^(z1 (al,be,ga) +z2 (al,be,ga) -1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,al,be,ga), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    pertY.  <-  function (mdl, x, ... ) {
            def. (c ('al', 'be', 'ga'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            z1  <-  function (al,be,ga)  1 +4 *(be -al) /(ga -al)
            z2  <-  function (al,be,ga)  1 +4 *(ga -be) /(ga -al)
            (x -al) ^(z1 (al,be,ga) -1) *(ga -x) ^(z2 (al,be,ga) -1) /beta (z1 (al,be,ga), z2 (al,be,ga)) /(ga -al) ^(z1 (al,be,ga) +z2 (al,be,ga) -1)  %>%  return (.)
    }

    ##  (modified) PERT2 distribution  == https://www.vosesoftware.com/riskwiki/ModifiedPERTdistribution.php ========================
    pert2F.  <-  function (x, y, ... ) {    #  min, mode, max, ?
            pLL  <-  list ( list (p = 0.1, q = x [which.max. (y)], r = max (x), s = 100), list (p = 0.1, q = x [which.max. (y)], r = max (x), s = 10) )
            z1  <-  function (p,q,r,s)  1 +s *(q -p) /(r -p)
            z2  <-  function (p,q,r,s)  1 +s *(r -q) /(r -p)
            f  <-  function (x,p,q,r,s)  (x -p) ^(z1 (p,q,r,s) -1) *(r - x) ^(z2 (p,q,r,s) -1) /beta (z1 (p,q,r,s), z2 (p,q,r,s)) /(r -p) ^(z1 (p,q,r,s) +z2 (p,q,r,s) -1)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,p,q,r,s), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    pert2Y.  <-  function (mdl, x, ... ) {
            def. (c ('p', 'q', 'r', 's'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            z1  <-  function (p,q,r,s)  1 +s *(q -p) /(r -p)
            z2  <-  function (p,q,r,s)  1 +s *(r -q) /(r -p)
            (x -p) ^(z1 (p,q,r,s) -1) *(r - x) ^(z2 (p,q,r,s) -1) /beta (z1 (p,q,r,s), z2 (p,q,r,s)) /(r -p) ^(z1 (p,q,r,s) +z2 (p,q,r,s) -1)  %>%  return (.)
    }

    ##  Prentice distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    prenticeF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam > 0, (shape) al, ga > 0; similar to Prentice, exBeta, and Logistic
            pLL  <-  list ( list (nu = x [which.max (y)], lam = 1, al = 1, ga = 10) )
            f  <-  function (x,nu,lam,al,ga)  1 /beta (al,ga) /abs (lam) *exp (-al *(x -nu) /lam) *(1 +exp (-(x -nu) /lam)) ^(-al -ga)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,ga), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    prenticeY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'ga'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            1 /beta (al,ga) *abs (1 /lam) *exp (-al *(x -nu) /lam) *(1 +exp (-(x -nu) /lam)) ^(-al -ga)  %>%  return (.)
    }

    ##  Rayleigh distribution  == (NOT) https://en.wikipedia.org/wiki/Rayleigh_distribution  == (BUT) https://github.com/cran/propagate/blob/master/R/distr-densities.R
    rayleighF.  <-  function (x, y, ... ) {    #  (location) nu > 0, (scale) lam > 0
            pLL  <-  list ( list (nu = x [which.max (y)], lam = sd (x *y)), list (nu = 10, lam = 10) )
            f  <-  function (x,nu,lam)  (x -nu) /lam ^2 *exp (-1/2 * ((x -nu) /lam) ^2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    rayleighY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            (x -nu) /lam ^2 *exp (-1/2 * ((x -nu) /lam) ^2) %>%  return (.)
    }

    ##  RBW (Relativeistic Breit-Wigner) distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ==
    rbwF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam > 0; similar to Pearson VII, Cauchy, RBW, and Student's t
            pLL  <-  list ( list (nu = sd (x *y), lam = sd (x *y)) )
            f  <-  function (x,nu,lam)  2 /pi /lam *(1 +((x -nu) /lam) ^2) ^(-2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    rbwY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            2 /pi /lam *(1 +((x -nu) /lam) ^2) ^(-2)  %>% return (.)
    }

    ##  Rice distribution  == https://en.wikipedia.org/wiki/Rice_distribution ========================
   riceF.  <-  function (x, y, ... ) {    #  (location) nu, (scale) lam, using modified Bessel function of the first kind with order zero
            pLL  <-  list ( list (nu = 1, lam = 1), list (nu = 0.1, lam = 1), list (nu = 0.01, lam = 0.1), list (nu = 1, lam = 10) )
            f  <-  function (x,nu,lam)  x /lam ^2 *exp (-1/2 *(x ^2 +nu ^2) /lam ^2) *besselI (x *nu /lam ^2, 0)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    riceY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam'), list (coef (mdl) [1], coef (mdl) [2] ))
            x /lam ^2 *exp (-1/2 *(x ^2 +nu ^2) /lam ^2) *besselI (x *nu /lam ^2, 0)  %>%  return (.)
    }

    ##  Rogin-Rammler distribution  == https://www.ugr.es/~fcamacho/Originales/Trabajos%20Publicados/PT_2008.pdf ========================
   roginF.  <-  function (x, y, ... ) {    #  equal to Weibull distribution
            pLL  <-  list ( list (lam = 10, al = 1), list (lam = sd (x *y), al = sd (x *y)) )
            f  <-  function (x,lam,al)  abs (al /lam) *(x /lam) ^(al -1) *exp (-(x /lam) ^al)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    roginY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al'), list (coef (mdl) [1], coef (mdl) [2] ))
            abs (al /lam) *(x /lam) ^(al -1) *exp (-(x /lam) ^al) %>%  return (.)
    }

    ##  Shifted Gompertz distribution  == https://en.wikipedia.org/wiki/Shifted_Gompertz_distribution ========================
    shGompF.  <-  function (x, y, ... ) {    #  (scale) lam >= 0, (shape) al >= 0;  I add 'nu' to the formula
            pLL  <-  list ( list (nu = sd (x *y), lam = sd (x *y), al = sd (x *y)), list (nu = 1, lam = 1, al = 1), list (nu = 10, lam = 1, al = 10) )
            f  <-  function (x,nu,lam,al)  1 /lam *exp (-(x -nu) /lam) *exp (-al *exp (-(x -nu) /lam)) *( 1 +al *(1 -exp (-(x -nu)/lam)) )
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    shGompY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            1 /lam *exp (-(x -nu) /lam) *exp (-al *exp (-(x -nu) /lam)) *( 1 +al *(1 -exp (-(x -nu)/lam)) )  %>%  return (.)
    }

    ##  Singh-Maddala distribution  == http://www.mathwave.com/articles/burr_singh_maddala_distribution.html ========================
    sinMadF.  <-  function (x, y, ... ) {    #  = BurrXII if nu = 0; sinMad is very similar to Dagum2. Its difference is ^(al-1), Dagum2 is ^(al*be-1)
            pLL  <-  list ( list (nu=1, lam=1, al=1, be=0.1), list (nu=1, lam=10, al=1, be=1), list (nu=0.1, lam=1, al=1, be=0.1), list (nu=10, lam=10, al=1, be=1), list (nu=1, lam=sd (x *y), al=sd (x *y), be=sd (x *y)), list (nu=1, lam=0.1, al=1, be=0.1) )
            f  <-  function (x,nu,lam,al,be)  abs (al *be /lam) *((x -nu) /lam) ^(al -1) *(1 + ((x -nu) /lam) ^al) ^(-be -1)    # Use abs () in contrast to Dagum2
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al,be), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    sinMadY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al', 'be'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3], coef (mdl) [4] ))
            abs (al *be /lam) *((x -nu) /lam) ^(al -1) *(1 + ((x -nu) /lam) ^al) ^(-be -1)  %>%  return (.)
    }

    ##  Skew Normal distribution  == https://en.wikipedia.org/wiki/Skew_normal_distribution ========================
   skewNF.  <-  function (x, y, ... ) {    #  (location) nu in R, (scale) lam > 0, (shape) al in R
            pLL  <-  list ( list (nu = x [which.max (y)], lam = sd (x *y), al = sd (x *y)), list (nu = sd (x *y), lam = x [which.max (y)], al = sd (x *y)) )
            f  <-  function (x,nu,lam,al)  2 /sqrt (2 *pi *lam^2) *exp (-1/2 *((x -nu) /lam) ^2) *stcum (al *(x -nu) /lam)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    skewNY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            2 /sqrt (2 *pi *lam^2) *exp (-1/2 *((x -nu) /lam) ^2) *stcum (al *(x -nu) /lam)  %>%  return (.)
    }

    ##  Skew Log-Normal distribution  == https://arxiv.org/pdf/1501.02344.pdf  ========================
   skewLogNF.  <-  function (x, y, ... ) {    #  (location) nu in R, (scale) lam > 0, (shape) al in R
            pLL  <-  list ( list (nu = x [which.max (y)], lam = sd (x *y), al = sd (x *y)), list (nu = sd (x *y), lam = x [which.max (y)], al = sd (x *y)) )
            f  <-  function (x,nu,lam,al)  2 /lam /sqrt (2 *pi *lam^2) *exp (-1/2 *((x -nu) /lam) ^2) *stcum (al *(x -nu) /lam)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    skewLogNY.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            2 /lam /sqrt (2 *pi *lam^2) *exp (-1/2 *((x -nu) /lam) ^2) *stcum (al *(x -nu) /lam)  %>%  return (.)
    }

    ##  Student's t distribution  == https://pdfs.semanticscholar.org/cf53/f8c9dfa71bf17649feb86af5d7d8d294b06a.pdf ========================
    studentsTF.  <-  function (x, y, ... ) {    # (degrees of freedom) n, similar to Pearson VII, Cauchy, RBW, and Student's t
            pLL  <-  list ( list (n = 1) )
            f  <-  function (x,n)  1 /sqrt (n) /beta (1/2,n /2) *(1 +x ^2 /n) ^(-(n +1) /2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,n), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    studentsTY.  <-  function (mdl, x, ... ) {
            def. (c ('n'), list (coef (mdl) [1] ))
            1 /sqrt (n) /beta (1/2,n /2) *(1 +x ^2 /n) ^(-(n +1) /2)  %>%  return (.)
    }

    ##  Three-parameter Lifetime distribution  == https://www.vosesoftware.com/riskwiki/Lifetime3distribution.php ========================
    life3F.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (p = 1, q = 0.1, r = 0.01), list (p = 0.1, q = 0, r = 0), list (p = 1, q = 0.01, r = 0.01) )
            f  <-  function (x,p,q,r)  (p +q *x +r *x ^2) *exp (-(p *x + q *x ^2 /2 +r *x ^3 /3))
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,p,q,r), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    life3Y.  <-  function (mdl, x, ... ) {
            def. (c ('p', 'q', 'r'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            (p +q *x +r *x ^2) *exp (-(p *x + q *x ^2 /2 +r *x ^3 /3))  %>%  return (.)
    }

    ##  Three-parameter Log-Hyperbolic distribution  == https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=2ahUKEwjc9NGnhOvgAhXLG6YKHeu5BfYQFjAAegQIBBAC&url=https%3A%2F%2Fwww.researchgate.net%2Fprofile%2FFranco_Concli%2Fpost%2FDoes_anybody_know_data_for_the_sauter_diameter_for_newtonian_drops_in_a_inelastic_power-law_fluid_Im_looking_for_data_in_a_stirred_vessel%2Fattachment%2F59d6274e79197b807798598b%2FAS%253A325311913840640%25401454571812030%2Fdownload%2FBabinsky2002-ModelingDropSizeDistributions.pdf&usg=AOvVaw0dpvUVX1DPMHSn4KxTkmRI ========================
    logHype3F.  <-  function (x, y, ... ) {    #  NOTE: modified Bessel function of the second kind = the third kind (https://en.wikipedia.org/wiki/Bessel_function)
            pLL  <-  list ( list (nu = x [which.max (y)], m = 1, the = pi) )
            al  <-  function (m,the)  m /(m ^2 *cos (the) ^2 -sin (the) ^2)
            be  <-  function (m,the)  (m ^2 +1) *sin (the) *cos (the) /(m ^2 *cos (the) ^2 -sin (the) ^2)
            ga  <-  function (m,the)  sqrt (m ^2 *cos (the) ^2 -sin (the) ^2)
            A  <-  function (m,the)  1 /2 /al(m,the) /ga(m,the) *sqrt (al(m,the) ^2 - be(m,the) ^2) /besselK (1, ga(m,the) *sqrt (al(m,the) ^2 - be(m,the) ^2))
            mu0  <-  function (m,the)  -be(m,the) *ga(m,the) /sqrt (al(m,the) ^2 - be(m,the) ^2)
            f  <-  function (x,nu,m,the)  A(m,the) *exp (-al(m,the) *sqrt (ga(m,the) ^2 +(x -nu +mu0(m,the)) ^2) -be(m,the) *(x -nu +mu0(m,the)) )
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,m,the), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    logHype3Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'm', 'the'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            al  <-  function (m,the)  m /(m ^2 *cos (the) ^2 -sin (the) ^2)
            be  <-  function (m,the)  (m ^2 +1) *sin (the) *cos (the) /(m ^2 *cos (the) ^2 -sin (the) ^2)
            ga  <-  function (m,the)  sqrt (m ^2 *cos (the) ^2 -sin (the) ^2)
            A  <-  function (m,the)  1 /2 /al(m,the) /ga(m,the) *sqrt (al(m,the) ^2 - be(m,the) ^2) /besselK (1, ga(m,the) *sqrt (al(m,the) ^2 - be(m,the) ^2))
            mu0  <-  function (m,the)  -be(m,the) *ga(m,the) /sqrt (al(m,the) ^2 - be(m,the) ^2)
            A(m,the) *exp (-al(m,the) *sqrt (ga(m,the) ^2 +(x -nu +mu0(m,the)) ^2) -be(m,the) *(x -nu +mu0(m,the)) )  %>%  return (.)
    }

    ##  Three-parameter Student distribution  == https://www.vosesoftware.com/riskwiki/Student3distribution.php ========================
    student3F.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (nu = x [which.max. (y)], lam = sd (x *y), n = 10) )
            f  <-  function (x,nu,lam,n)  gamma ((n +1) /2) /gamma (n /2) /lam /sqrt (pi *(n -2))  *(1 +((x -nu) /lam) ^2 /(n-2) ) ^(-(n +1) /2)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,n), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    student3Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'n'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            gamma ((n +1) /2) /gamma (n /2) /lam /sqrt (pi *(n -2))  *(1 +((x -nu) /lam) ^2 /(n-2) ) ^(-(n +1) /2)  %>% return (.)
    }

    ##  Three-parameter Weibull distribution  == https://www.vosesoftware.com/riskwiki/Weibull3distribution.php ========================
    weibull3F.  <-  function (x, y, ... ) {
            pLL  <-  list ( list (nu=1, lam=1, al=1), list (nu=0.1, lam=10, al=10), list (nu=0.01, lam=0.1, al=1), list (nu=0.1, lam=10, al=1), list (nu=1, lam=10, al=1) )
            f  <-  function (x,nu,lam,al)  abs (al /lam) *((x -nu) /lam) ^(al -1) *exp (-((x -nu) /lam) ^al)
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,nu,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    weibull3Y.  <-  function (mdl, x, ... ) {
            def. (c ('nu', 'lam', 'al'), list (coef (mdl) [1], coef (mdl) [2], coef (mdl) [3] ))
            abs (al /lam) *((x -nu) /lam) ^(al -1) *exp (-((x -nu) /lam) ^al)  %>%  return (.)
    }

    ##  Weibull distribution  == https://en.wikipedia.org/wiki/Weibull_distribution ========================
    weibullF.  <-  function (x, y, ... ) {    #  (scale) lam > 0, (shape) al > 0;  equal to Rogin-Rammler distirbution
            pLL  <-  list ( list (lam = 10, al = 1), list (lam = sd (x *y), al = sd (x *y)) )
            f  <-  function (x,lam,al)  abs (al /lam) *(x /lam) ^(al -1) *exp (- (x /lam) ^al)    # Without abs (), the AIC will be worse.
            mL  <-  list ()
            for (i in seq_along (pLL))  mL [[i]]  <- tryReturn. (nlsLM (y ~ f (x,lam,al), start = pLL [[i]]) )
            map. (mL, ~ {if (! anyNA (.)) deviance (.) else NA}) %>%  {which.min. (.) [1]}  %>%  {if (is.null (.))  NULL  else mL [[.]]}  %>%  return (.)
    }
    weibullY.  <-  function (mdl, x, ... ) {
            def. (c ('lam', 'al'), list (coef (mdl) [1], coef (mdl) [2] ))
            abs (al /lam) *(x /lam) ^(al -1) *exp (- (x /lam) ^al)  %>%  return (.)
    }


  x  <-  c (2.23,2.2939263803681,2.3578527607362,2.42177914110429,2.48570552147239,2.54963190184049,2.61355828220859,2.67748466257669,2.74141104294479,2.80533742331288,2.86926380368098,2.93319018404908,2.99711656441718,3.06104294478528,3.12496932515337,3.18889570552147,3.25282208588957,3.31674846625767,3.38067484662577,3.44460122699387,3.50852760736196,3.57245398773006,3.63638036809816,3.70030674846626,3.76423312883436,3.82815950920245,3.89208588957055,3.95601226993865,4.01993865030675,4.08386503067485,4.14779141104294,4.21171779141104,4.27564417177914,4.33957055214724,4.40349693251534,4.46742331288343,4.53134969325153,4.59527607361963,4.65920245398773,4.72312883435583,4.78705521472393,4.85098159509202,4.91490797546012,4.97883435582822,5.04276073619632,5.10668711656442,5.17061349693252,5.23453987730061,5.29846625766871,5.36239263803681,5.42631901840491,5.49024539877301,5.5541717791411,5.6180981595092,5.6820245398773,5.7459509202454,5.8098773006135,5.8738036809816,5.93773006134969,6.00165644171779,6.06558282208589,6.12950920245399,6.19343558282209,6.25736196319018,6.32128834355828,6.38521472392638,6.44914110429448,6.51306748466258,6.57699386503067,6.64092024539877,6.70484662576687,6.76877300613497,6.83269938650307,6.89662576687117,6.96055214723926,7.02447852760736,7.08840490797546,7.15233128834356,7.21625766871166,7.28018404907975,7.34411042944785,7.40803680981595,7.47196319018405,7.53588957055215,7.59981595092025,7.66374233128834,7.72766871165644,7.79159509202454,7.85552147239264,7.91944785276073,7.98337423312883,8.04730061349693,8.11122699386503,8.17515337423313,8.23907975460123,8.30300613496932,8.36693251533742,8.43085889570552,8.49478527607362,8.55871165644172,8.62263803680982,8.68656441717791,8.75049079754601,8.81441717791411,8.87834355828221,8.94226993865031,9.0061963190184,9.0701226993865,9.1340490797546,9.1979754601227,9.2619018404908,9.3258282208589,9.38975460122699,9.45368098159509,9.51760736196319,9.58153374233129,9.64546012269939,9.70938650306748,9.77331288343558,9.83723926380368,9.90116564417178,9.96509202453988,10.029018404908,10.0929447852761,10.1568711656442,10.2207975460123,10.2847239263804,10.3486503067485,10.4125766871166,10.4765030674847,10.5404294478528,10.6043558282209,10.668282208589,10.7322085889571,10.7961349693252,10.8600613496933,10.9239877300613,10.9879141104294,11.0518404907975,11.1157668711656,11.1796932515337,11.2436196319018,11.3075460122699,11.371472392638,11.4353987730061,11.4993251533742,11.5632515337423,11.6271779141104,11.6911042944785,11.7550306748466,11.8189570552147,11.8828834355828,11.9468098159509,12.010736196319,12.0746625766871,12.1385889570552,12.2025153374233,12.2664417177914,12.3303680981595,12.3942944785276,12.4582208588957,12.5221472392638,12.5860736196319,12.65,12.7139263803681,12.7778527607362,12.8417791411043,12.9057055214724,12.9696319018405,13.0335582822086,13.0974846625767,13.1614110429448,13.2253374233129,13.289263803681,13.3531901840491,13.4171165644172,13.4810429447853,13.5449693251534,13.6088957055215,13.6728220858896,13.7367484662577,13.8006748466258,13.8646012269939,13.928527607362,13.9924539877301,14.0563803680982,14.1203067484663,14.1842331288344,14.2481595092025,14.3120858895706,14.3760122699387,14.4399386503067,14.5038650306748,14.5677914110429,14.631717791411,14.6956441717791,14.7595705521472,14.8234969325153,14.8874233128834,14.9513496932515,15.0152760736196,15.0792024539877,15.1431288343558,15.2070552147239,15.270981595092,15.3349079754601,15.3988343558282,15.4627607361963,15.5266871165644,15.5906134969325,15.6545398773006,15.7184662576687,15.7823926380368,15.8463190184049,15.910245398773,15.9741717791411,16.0380981595092,16.1020245398773,16.1659509202454,16.2298773006135,16.2938036809816,16.3577300613497,16.4216564417178,16.4855828220859,16.549509202454,16.6134355828221,16.6773619631902,16.7412883435583,16.8052147239264,16.8691411042945,16.9330674846626,16.9969938650307,17.0609202453988,17.1248466257669,17.188773006135,17.2526993865031,17.3166257668712,17.3805521472393,17.4444785276074,17.5084049079755,17.5723312883436,17.6362576687117,17.7001840490798,17.7641104294479,17.8280368098159,17.891963190184,17.9558895705521,18.0198159509202,18.0837423312883,18.1476687116564,18.2115950920245,18.2755214723926,18.3394478527607,18.4033742331288,18.4673006134969,18.531226993865,18.5951533742331,18.6590797546012,18.7230061349693,18.7869325153374,18.8508588957055,18.9147852760736,18.9787116564417,19.0426380368098,19.1065644171779,19.170490797546,19.2344171779141,19.2983435582822,19.3622699386503,19.4261963190184,19.4901226993865,19.5540490797546,19.6179754601227,19.6819018404908,19.7458282208589,19.809754601227,19.8736809815951,19.9376073619632,20.0015337423313,20.0654601226994,20.1293865030675,20.1933128834356,20.2572392638037,20.3211656441718,20.3850920245399,20.449018404908,20.5129447852761,20.5768711656442,20.6407975460123,20.7047239263804,20.7686503067485,20.8325766871166,20.8965030674847,20.9604294478528,21.0243558282209,21.088282208589,21.1522085889571,21.2161349693252,21.2800613496933,21.3439877300613,21.4079141104294,21.4718404907975,21.5357668711656,21.5996932515337,21.6636196319018,21.7275460122699,21.791472392638,21.8553987730061,21.9193251533742,21.9832515337423,22.0471779141104,22.1111042944785,22.1750306748466,22.2389570552147,22.3028834355828,22.3668098159509,22.430736196319,22.4946625766871,22.5585889570552,22.6225153374233,22.6864417177914,22.7503680981595,22.8142944785276,22.8782208588957,22.9421472392638,23.0060736196319,23.07)

  y  <-  c (0.000280812948353254,0.000528777494344888,0.000783799453174506,0.00105293623768002,0.00134324526069949,0.00166178393507082,0.00201560967363199,0.00241198029527048,0.00286132030619014,0.00337658083103742,0.00397078333715442,0.00465694929188316,0.00544810016256576,0.00635725741654427,0.00739744299068701,0.00858292819370981,0.00993194773409459,0.0114635204266683,0.0131966650862579,0.0151504005276904,0.0173437455657927,0.0197957190153917,0.0225253396913145,0.0255515174749326,0.0288858231870999,0.0325279646205555,0.0364765699103036,0.0407302671913491,0.0452876845986964,0.05014745026735,0.0553081923323146,0.0607685389285947,0.0665271181911949,0.0725825582551197,0.0789286222093245,0.0855270859424578,0.0923268064630062,0.0992766047312,0.10632530170727,0.113421718351445,0.120514675623957,0.127552994485036,0.134485495894911,0.141261000813814,0.147828330201975,0.154136305019623,0.160134629577287,0.165795490707352,0.171114830961629,0.176089731123984,0.180717271978282,0.18499453430839,0.188918598898173,0.192486546531498,0.195695457992229,0.198542414064234,0.201024495531378,0.203138783177527,0.204882357786547,0.206252300142303,0.207245691028663,0.207861256849253,0.20811093489321,0.208013020415348,0.207585849306624,0.206847757457994,0.205817080760415,0.204512155104845,0.202951316382241,0.20115290048356,0.199135243299758,0.196916680721793,0.194515548640621,0.1919501829472,0.189238919532487,0.186400094287438,0.18345204310301,0.180413101870162,0.177301253537637,0.17412844722279,0.170901569314161,0.167627349355248,0.164312516889551,0.160963801460569,0.157587932611802,0.154191639886749,0.150781652828909,0.147364700981781,0.143947513888866,0.140536821093663,0.13713935213967,0.133761836570388,0.130411003929316,0.127093583759952,0.123816305605797,0.12058589901035,0.11740909351711,0.114292618669576,0.111243187922831,0.108265151681002,0.105358027986138,0.102520744190102,0.0997522276447579,0.0970514057019702,0.0944172057136024,0.0918485550315184,0.0893443810075821,0.0869036109936572,0.0845251723416078,0.0822079924032977,0.0799509985305906,0.0777531180753506,0.0756132783894413,0.0735304068247268,0.0715034307330709,0.0695312774663374,0.0676128743763902,0.0657471488150932,0.0639330281343103,0.0621694396859052,0.0604553108217418,0.0587895688936841,0.0571711413073363,0.0555989836910475,0.0540721261105786,0.0525896107604978,0.0511504798353737,0.0497537755297747,0.0483985400382692,0.0470838155554256,0.0458086442758125,0.0445720683939981,0.0433731301045509,0.0422108716020394,0.041084335081032,0.0399925627360971,0.0389345967618031,0.0379094793527185,0.0369162527034117,0.0359539590084512,0.0350216404624053,0.0341183392598425,0.0332430975953312,0.0323949576634399,0.031572961658737,0.0307761517757908,0.0300035702091699,0.0292542591534427,0.0285272608031775,0.0278216173529429,0.0271363709973073,0.0264705914311138,0.0258236632628679,0.0251951720256259,0.0245847065017291,0.023991855473519,0.0234162077233372,0.0228573520335251,0.0223148771864242,0.021788371964376,0.021277425149722,0.0207816255248037,0.0203005618719625,0.01983382297354,0.0193809976118777,0.0189416745693171,0.0185154426281995,0.0181018905708666,0.0177006071796598,0.0173111812369206,0.0169332015249905,0.016566256826211,0.0162099359229235,0.0158638275974697,0.0155275206321908,0.0152006038094286,0.0148826659115243,0.0145732957208196,0.0142720820196559,0.0139786135903747,0.0136924792153176,0.0134132676768259,0.0131405677572411,0.0128739682389049,0.0126130579075219,0.0123574921049882,0.012107163482649,0.0118620175604266,0.011621999858243,0.0113870558960205,0.0111571311936812,0.0109321712711474,0.0107121216483411,0.0104969278451847,0.0102865353816002,0.0100808897775098,0.00987993655283572,0.00968362122750013,0.00949188932142524,0.00930468635453316,0.0091219578467461,0.00894364931798627,0.00876970628817579,0.00860007427723686,0.0084346988050917,0.0082735253916624,0.00811649955687122,0.00796356682064029,0.00781467270289181,0.00766976272354795,0.00752878240253089,0.0073916772597628,0.00725839281516585,0.00712887458866224,0.00700306810017411,0.00688091886962372,0.00676237241693317,0.00664737426202465,0.00653586992482037,0.00642780492524246,0.00632312478321312,0.00622177501865454,0.00612370115148891,0.00602884870163835,0.00593716302401681,0.0058485772261004,0.00576300394310975,0.00568035386293292,0.00560053767345793,0.00552346606257286,0.00544904971816574,0.0053771993281246,0.00530782558033751,0.00524083916269252,0.00517615076307763,0.00511367106938095,0.00505331076949047,0.00499498055129426,0.00493859110268036,0.00488405311153683,0.00483127726575169,0.00478017425321302,0.00473065476180882,0.00468262947942718,0.00463600909395611,0.00459070429328369,0.00454662576529795,0.00450368419788693,0.00446179027893865,0.00442085469634123,0.00438078813798265,0.00434150129175097,0.00430290484553425,0.00426490948722054,0.00422742590469784,0.00419036478585424,0.00415363681857779,0.00411715269075652,0.00408082309027844,0.00404455870503165,0.00400827022290419,0.00397186833178409,0.00393526371955939,0.00389836707411815,0.00386108908334841,0.00382334043513821,0.0037850318173756,0.0037460739179486,0.00370637742474531,0.00366585302565377,0.00362441140856196,0.00358196598598357,0.00353848418656682,0.00349398304616203,0.00344848144145415,0.00340199824912819,0.00335455234586906,0.00330616260836174,0.00325684791329126,0.00320662713734247,0.00315551915720046,0.00310354284955009,0.00305071709107637,0.00299706075846423,0.0029425927283987,0.00288733187756468,0.00283129708264714,0.00277450722033104,0.00271698116730143,0.00265873780024316,0.00259979599584125,0.00254017463078066,0.00247989258174633,0.00241896872542325,0.00235742193849635,0.00229527109765065,0.00223253507957106,0.00216923276094258,0.00210538301845014,0.00204100472877873,0.00197611676861328,0.00191073801463882,0.00184488734354025,0.00177858363200255,0.0017118457567107,0.00164469259434963,0.00157714302160436,0.00150921591515978,0.00144093015170094,0.00137230460791273,0.00130335816048011,0.00123410968608811,0.00116457806142167,0.00109478216316571,0.00102474086800522,0.000954473052625196,0.000883997593710563,0.000813333367946284,0.000742499252017356,0.000671514122608694,0.00060039685640528,0.000529166330092114,0.000457841420354109,0.000386441003876256,0.000314983957343516,0.000243489157440855,0.000171975480853242)
